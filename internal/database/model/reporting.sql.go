// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reporting.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const getInvoiceStatusSummary = `-- name: GetInvoiceStatusSummary :many
SELECT status, COUNT(*) AS count
FROM invoices
WHERE tenant_id = $1
GROUP BY status
`

type GetInvoiceStatusSummaryRow struct {
	Status string `json:"status"`
	Count  int64  `json:"count"`
}

func (q *Queries) GetInvoiceStatusSummary(ctx context.Context, tenantID uuid.UUID) ([]GetInvoiceStatusSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getInvoiceStatusSummary, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvoiceStatusSummaryRow{}
	for rows.Next() {
		var i GetInvoiceStatusSummaryRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutstandingInvoices = `-- name: GetOutstandingInvoices :many
SELECT i.id AS invoice_id,
       i.customer_email,
       i.amount_cents,
       i.currency,
       i.due_at,
       (i.amount_cents - COALESCE(SUM(p.amount_cents), 0)) AS outstanding_cents
FROM invoices i
LEFT JOIN payments p ON i.id = p.invoice_id AND p.status = 'success'
WHERE i.tenant_id = $1
  AND i.status = 'pending'
GROUP BY i.id, i.customer_email, i.amount_cents, i.currency, i.due_at
ORDER BY i.due_at ASC
`

type GetOutstandingInvoicesRow struct {
	InvoiceID        uuid.UUID    `json:"invoice_id"`
	CustomerEmail    string       `json:"customer_email"`
	AmountCents      int32        `json:"amount_cents"`
	Currency         string       `json:"currency"`
	DueAt            sql.NullTime `json:"due_at"`
	OutstandingCents int32        `json:"outstanding_cents"`
}

func (q *Queries) GetOutstandingInvoices(ctx context.Context, tenantID uuid.UUID) ([]GetOutstandingInvoicesRow, error) {
	rows, err := q.db.QueryContext(ctx, getOutstandingInvoices, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOutstandingInvoicesRow{}
	for rows.Next() {
		var i GetOutstandingInvoicesRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.CustomerEmail,
			&i.AmountCents,
			&i.Currency,
			&i.DueAt,
			&i.OutstandingCents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentProviderSummary = `-- name: GetPaymentProviderSummary :many
SELECT provider, COUNT(*) AS count, COALESCE(SUM(amount_cents), 0) AS total_cents
FROM payments
WHERE tenant_id = $1
GROUP BY provider
`

type GetPaymentProviderSummaryRow struct {
	Provider   string      `json:"provider"`
	Count      int64       `json:"count"`
	TotalCents interface{} `json:"total_cents"`
}

func (q *Queries) GetPaymentProviderSummary(ctx context.Context, tenantID uuid.UUID) ([]GetPaymentProviderSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentProviderSummary, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPaymentProviderSummaryRow{}
	for rows.Next() {
		var i GetPaymentProviderSummaryRow
		if err := rows.Scan(&i.Provider, &i.Count, &i.TotalCents); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevenueOverTime = `-- name: GetRevenueOverTime :many
SELECT DATE_TRUNC('month', p.created_at) AS month,
       COALESCE(SUM(p.amount_cents), 0) AS total_revenue_cents
FROM payments p
WHERE p.tenant_id = $1
  AND p.status = 'success'
GROUP BY month
ORDER BY month ASC
`

type GetRevenueOverTimeRow struct {
	Month             int64       `json:"month"`
	TotalRevenueCents interface{} `json:"total_revenue_cents"`
}

func (q *Queries) GetRevenueOverTime(ctx context.Context, tenantID uuid.UUID) ([]GetRevenueOverTimeRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevenueOverTime, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRevenueOverTimeRow{}
	for rows.Next() {
		var i GetRevenueOverTimeRow
		if err := rows.Scan(&i.Month, &i.TotalRevenueCents); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopCustomers = `-- name: GetTopCustomers :many
SELECT customer_email,
       COALESCE(SUM(p.amount_cents), 0) AS total_spent_cents
FROM invoices i
LEFT JOIN payments p ON i.id = p.invoice_id AND p.status = 'success'
WHERE i.tenant_id = $1
GROUP BY customer_email
ORDER BY total_spent_cents DESC
LIMIT $2 OFFSET $3
`

type GetTopCustomersParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

type GetTopCustomersRow struct {
	CustomerEmail   string      `json:"customer_email"`
	TotalSpentCents interface{} `json:"total_spent_cents"`
}

func (q *Queries) GetTopCustomers(ctx context.Context, arg GetTopCustomersParams) ([]GetTopCustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopCustomers, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopCustomersRow{}
	for rows.Next() {
		var i GetTopCustomersRow
		if err := rows.Scan(&i.CustomerEmail, &i.TotalSpentCents); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
