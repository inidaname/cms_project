// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invoices_with_payments.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const getInvoiceWithPayments = `-- name: GetInvoiceWithPayments :many
SELECT i.id AS invoice_id,
       i.tenant_id,
       i.user_id,
       i.customer_email,
       i.amount_cents,
       i.currency,
       i.status AS invoice_status,
       i.issued_at,
       i.due_at,
       p.id AS payment_id,
       p.amount_cents AS payment_amount,
       p.currency AS payment_currency,
       p.provider,
       p.status AS payment_status,
       p.transaction_ref,
       p.created_at AS payment_created_at
FROM invoices i
LEFT JOIN payments p ON i.id = p.invoice_id
WHERE i.id = $1
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type GetInvoiceWithPaymentsParams struct {
	ID     uuid.UUID `json:"id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type GetInvoiceWithPaymentsRow struct {
	InvoiceID        uuid.UUID      `json:"invoice_id"`
	TenantID         uuid.UUID      `json:"tenant_id"`
	UserID           uuid.NullUUID  `json:"user_id"`
	CustomerEmail    string         `json:"customer_email"`
	AmountCents      int32          `json:"amount_cents"`
	Currency         string         `json:"currency"`
	InvoiceStatus    string         `json:"invoice_status"`
	IssuedAt         time.Time      `json:"issued_at"`
	DueAt            sql.NullTime   `json:"due_at"`
	PaymentID        uuid.NullUUID  `json:"payment_id"`
	PaymentAmount    sql.NullInt32  `json:"payment_amount"`
	PaymentCurrency  sql.NullString `json:"payment_currency"`
	Provider         sql.NullString `json:"provider"`
	PaymentStatus    sql.NullString `json:"payment_status"`
	TransactionRef   sql.NullString `json:"transaction_ref"`
	PaymentCreatedAt sql.NullTime   `json:"payment_created_at"`
}

func (q *Queries) GetInvoiceWithPayments(ctx context.Context, arg GetInvoiceWithPaymentsParams) ([]GetInvoiceWithPaymentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getInvoiceWithPayments, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvoiceWithPaymentsRow{}
	for rows.Next() {
		var i GetInvoiceWithPaymentsRow
		if err := rows.Scan(
			&i.InvoiceID,
			&i.TenantID,
			&i.UserID,
			&i.CustomerEmail,
			&i.AmountCents,
			&i.Currency,
			&i.InvoiceStatus,
			&i.IssuedAt,
			&i.DueAt,
			&i.PaymentID,
			&i.PaymentAmount,
			&i.PaymentCurrency,
			&i.Provider,
			&i.PaymentStatus,
			&i.TransactionRef,
			&i.PaymentCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
