// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tenant_users.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const listTenantUsersWithInvoices = `-- name: ListTenantUsersWithInvoices :many
SELECT u.id AS user_id,
       u.email,
       u.role,
       u.created_at AS user_created_at,
       i.id AS invoice_id,
       i.amount_cents,
       i.currency,
       i.status AS invoice_status,
       i.issued_at,
       i.due_at
FROM users u
LEFT JOIN invoices i ON u.id = i.user_id
WHERE u.tenant_id = $1
ORDER BY u.created_at DESC, i.issued_at DESC
LIMIT $2 OFFSET $3
`

type ListTenantUsersWithInvoicesParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

type ListTenantUsersWithInvoicesRow struct {
	UserID        uuid.UUID      `json:"user_id"`
	Email         string         `json:"email"`
	Role          string         `json:"role"`
	UserCreatedAt time.Time      `json:"user_created_at"`
	InvoiceID     uuid.NullUUID  `json:"invoice_id"`
	AmountCents   sql.NullInt32  `json:"amount_cents"`
	Currency      sql.NullString `json:"currency"`
	InvoiceStatus sql.NullString `json:"invoice_status"`
	IssuedAt      sql.NullTime   `json:"issued_at"`
	DueAt         sql.NullTime   `json:"due_at"`
}

func (q *Queries) ListTenantUsersWithInvoices(ctx context.Context, arg ListTenantUsersWithInvoicesParams) ([]ListTenantUsersWithInvoicesRow, error) {
	rows, err := q.db.QueryContext(ctx, listTenantUsersWithInvoices, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTenantUsersWithInvoicesRow{}
	for rows.Next() {
		var i ListTenantUsersWithInvoicesRow
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Role,
			&i.UserCreatedAt,
			&i.InvoiceID,
			&i.AmountCents,
			&i.Currency,
			&i.InvoiceStatus,
			&i.IssuedAt,
			&i.DueAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
